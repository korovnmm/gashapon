import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import * as crypto from "crypto";

admin.initializeApp();

const db = admin.firestore();
/**
 * A prizepool object containing an array of
 * prize data and a total amount of cumulative
 * prize quantities within that array.
 */
class PrizePool {
  totalAmount : number;
  prizes : {id : string, quantity : number}[];

  /** 
  * Initializes an empty prize pool. 
  */
  constructor() {
    this.totalAmount = 0;
    this.prizes = [];
  }
}

// Helper Functions
/**
 * Queries firestore for prizes generated by the user
 * @param {string} uid the user's id
 * @return {PrizePool} a PrizePool instance containing prize data
 */
async function getUserPrizePool(uid : string) : Promise<PrizePool> {
  const query = db.collection("prizes")
      .where("creatorUserID", "==", uid)
      .where("quantity", ">", 0);

  const data = new PrizePool();

  await query.get()
      .then((snapshot) => {
        snapshot.forEach((doc) => {
          const prizeData = {
            id: doc.id,
            quantity: doc.get("quantity") as number,
          };
          data.totalAmount += prizeData.quantity;
          data.prizes.push(prizeData);
        });
      })

      .catch((error) => {
        console.log(error);
        throw new functions.https.HttpsError("unknown", error);
      });

  return data;
}


/**
 * Simple guard function that asserts user authentication.
 * @param {functions.https.CallableContext} context
 * @throws HttpsError if the user is not authenticated
 */
function checkAuthentication(context : functions.https.CallableContext) {
  if (!context.auth) {
    // Throw an error if not
    throw new functions.https.HttpsError("unauthenticated",
        "The function must be called " +
        "while authenticated.");
  }
}

/**
 * Checks whether user account data exists in Firestore for the given uid.
 * @param {string} uid user id
 * @return {Promise<boolean>} true if user account data exists
 */
async function accountExists(uid : string) : Promise<boolean> {
  const docRef = db.collection("users").doc(uid);

  return docRef.get().then((doc) => {
    return doc.exists;
  })
      .catch((error) => {
        console.log(error);
        throw new functions.https.HttpsError("unknown", error);
      });
}


// Endpoint Functions
/**
 * Example function for development reference.
 * res.json() to send back JSON data.
 * res.send() if you want to return plain html inside a string.
 * res.status(200).json() if you want to send a
 * status code (change 200 to any code you want).
 * Look up documentation on Express endpoints for more info.
 *
 * To test your functions in an emulator, run
 * `npm run build` in the functions directory (to compile ts code)
 * and `firebase emulators:start` in the gashapon directory.
 *
 * Alternatively: `npm run func` in the gashapon directory.
 */
export const helloWorld = functions.https.onRequest(async (req, res) => {
  res.json({data: "World!"});
});


/**
 * Example function for GET requests using onRequest.
 * Note that onRequest can send explicit status codes,
 * while onCall must return a dictionary in JSON format.
 */
export const getExample = functions.https.onRequest(async (req, res) => {
  db.doc("/ticket-info/shopname").get()
      .then((snapshot) => {
        const data = snapshot.data();
        res.send(data);
      })
      .catch((error) => {
        console.log(error);
        res.status(500).send(error);
      });
});


/**
 * Called when a user logs in or creates a new account and \
 * performs any required operations.
 * @returns "created" result status if a new account was created,
 * "success" otherwise (i.e. if no new account created).
 */
export const userLoggedIn = functions.https.onCall(async (data, context) => {
  // Check if the user is authenticated
  checkAuthentication(context);

  // Get the user's id and email
  const uid = context.auth?.uid as string;
  const email = await admin.auth().getUser(uid)
      .then((userRecord) => {
        return userRecord.email as string;
      });

  // Initialize the account if it's new
  const newAccountCreated = await initUserAccount(uid, email);
  if (newAccountCreated) {
    return {result: "created"};
  } else {
    return {result: "success"};
  }
});


/**
 * Initializes user data in the Firestore database with default information.
 * Helper function for {@link userLoggedIn}.
 * @param {string} uid
 * @param {string} email
 * @return {Promise<boolean>} true if a new account had to be initialized
 */
async function initUserAccount(uid : string, email : string): Promise<boolean> {
  // Check if account data exists already
  if (await accountExists(uid)) {
    return false;
  }

  // Create a default shop tag from the user's email
  const emailPrefix = email.split("@")[0];
  const numChars = emailPrefix.length >= 5 ? 5 : emailPrefix.length;
  let defaultTag = emailPrefix.substring(0, numChars).toLowerCase();

  // Append a number if the default tag already exists
  await db.collection("users")
      .where("shopTag", "==", defaultTag).get()
      .then((snapshot) => {
        if (!snapshot.empty) {
          defaultTag = `${defaultTag}${snapshot.size+1}`;
        }
      });

  // Put the data entry together
  const timestamp = await admin.firestore.FieldValue.serverTimestamp();
  const userData = {
    createdAt: timestamp,
    shopTag: defaultTag,
    shopDisplayName: null,
    // TODO: prompt account setup if shop name hasn't been configured
  };

  // Write to firestore
  await db.collection("users").doc(uid).set(userData)
      .catch((error) => {
        console.log(error);
        throw new functions.https.HttpsError("unknown", error);
      });

  return true;
}


// -- ENDPOINT FUNCTIONS BELOW -- //

export const generateTickets = functions.https.onCall(async (data, context) => {
  // Data
  const email = data.email;
  const memo = data.memo;
  const amount = data.amount;

  // Check if user is authenticated
  checkAuthentication(context);

  // Check the amount variable is within range
  if (amount > 10 || amount < 1) {
    throw new functions.https.HttpsError("out-of-range",
        "A minimum of 1 and a maximum of 10 tickets " +
      "can be generated at a time.");
  }

  // Grab user info (id, shop tag, prizes)
  const uid = context.auth?.uid as string;
  const shopTag = await db.doc(`/users/${uid}`).get()
      .then((snapshot) => {
        const data = snapshot.data() as FirebaseFirestore.DocumentData;
        return data.shopTag as string;
      })
      .catch((error) => {
        console.log(error);
        throw new functions.https.HttpsError("unknown", error);
      });
  const prizePool = await getUserPrizePool(uid);

  // Make sure there are enough prizes for each ticket
  if (prizePool.totalAmount < amount) {
    throw new functions.https.HttpsError("out-of-range",
        "Not enough prizes for each ticket! " +
        "You can stock more prizes from the \"Inventory\" tab.");
  }

  // Generate ticket data
  const tickets : any = {};
  const timestamp = await admin.firestore.FieldValue.serverTimestamp();
  for (let i = 0; i < amount; i++) {
    // Generate a unique code
    let suffix = crypto.randomBytes(3).toString("hex").toUpperCase();
    let code = `${shopTag}-${suffix}`;
    let ticketPath = `/ticket-info/${code}`;
    while ((await db.doc(ticketPath).get()).exists) { // avoids duplicates
      suffix = crypto.randomBytes(3).toString("hex").toUpperCase();
      code = `${shopTag}-${suffix}`;
      ticketPath = `/ticket-info/${code}`;
    }

    // Select random index in the prize pool array
    const index = () => {
      return Math.floor(Math.random() * prizePool.prizes.length);
    };

    // Choose random prize based on that random index
    let prize : { id: string, quantity: number } = prizePool.prizes[index()];

    // Reroll if the prize quantity is 0
    while (prize.quantity <= 0) {
      prize = prizePool.prizes[index()];
    }

    // Decrement the prize quantity by 1
    prize.quantity -= 1;

    // Create the JSON object
    const ticketData = {
      createdAt: timestamp,
      email,
      memo,
      orderID: null,
      prizeID: prize.id,
      redeemed: false,
      shipped: false,
    };

    // Write to firestore
    db.collection("ticket-info").doc(code).set(ticketData)
        .catch((error) => {
          console.log(error);
          throw new functions.https.HttpsError("unknown", error);
        });

    // Append to list
    tickets[code] = ticketData;
  } // end of for-loop

  // Write the new prize quantities to firestore
  // by updating the existing documents
  await prizePool.prizes.forEach((prize) => {
    return db.doc(`prizes/${prize.id}`).update({
        quantity: prize.quantity,
      })
      .catch((error) => {
        console.log(error);
        throw new functions.https.HttpsError("unknown", error);
      });
  });

  return tickets;
});


export const addNewPrize = functions.https.onCall(async (data, context) => {
  // Data
  const name = data.name;
  const description = data.description;
  const quantity = parseInt(data.quantity);
  const url = data.image;

  // Check if user is authenticated
  if (!context.auth) {
    // Throw an error if not
    throw new functions.https.HttpsError("unauthenticated",
        "The function must be called " +
      "while authenticated.");
  }
  // Check the amount variable is within range
  if (quantity < 0 || quantity > 999) {
    throw new functions.https.HttpsError("out-of-range",
        "Prize quantity must be between 0 and 999 (inclusive)");
  }

  // Generate prize data
  const timestamp = await admin.firestore.FieldValue.serverTimestamp();

  // prizes collection
  const prizeMetaData = {
    createdAt: timestamp,
    creatorUserID: context.auth.uid,
    quantity,
  };

  // prizes-info collecton
  const prizeInfoData = {
    description,
    image: url,
    name,
    lastModified: timestamp,
  };

  // Write both documents to firestore
  let id;
  await db.collection("prizes").add(prizeMetaData)
      .then((docRef) => {
        id = docRef.id;
        db.collection("prize-info").doc(id).set(prizeInfoData)
            .catch((error) => {
              console.log(error);
              throw new functions.https.HttpsError("unknown", error);
            });
      })
      .catch((error) => {
        console.log(error);
        throw new functions.https.HttpsError("unknown", error);
      });

  // Append to list
  return {id, prizeMetaData, prizeInfoData};
});
